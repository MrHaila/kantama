# Opas E2E Testing Plan

## Problem Statement

Opas relies on data generated by Varikko (262 zones, 786 route files). Running full Varikko pipeline is slow and data isn't committed to git. Need reliable, fast E2E tests that:
- Work with partial/missing data
- Stay in sync with real data formats
- Are deterministic and fast
- Catch real bugs

## Fixture Strategy

### Option 1: Snapshot & Minimal Fixtures (Recommended)

**Approach:**
1. Create `tests/fixtures/` with minimal but real data subset
2. Add script `pnpm test:create-fixtures` that snapshots current production data
3. Commit fixtures to git for CI/CD stability
4. Fixtures include:
   - `zones.json` - 5-10 carefully chosen zones covering edge cases
   - `manifest.json` - matching metadata
   - `routes/` - route files for selected zones (all 3 time periods)
   - `background_map.json` - minimal map data

**Chosen Test Zones (10 zones):**
- `HEL-101` (Vilhonvuori) - Central Helsinki, excellent connectivity
- `HEL-201` - Different area, good connectivity
- `ESP-111` - Espoo zone, moderate connectivity
- `VAN-151` - Vantaa zone, different city
- One zone with NO routes (for error handling)
- One zone on edge of map (boundary testing)
- One zone with very poor connectivity (rank bottom 10%)
- One zone with exactly 1 route
- One zone with many routes (>200 destinations)
- One isolated zone (0 routes within 15min)

**Fixture Update Strategy:**
```bash
# When Varikko data format changes
pnpm test:update-fixtures

# Validates fixtures match current schema
pnpm test:validate-fixtures
```

### Option 2: Mock Service Worker (MSW)

Mock network requests at runtime. More flexible but harder to maintain as data formats evolve. **Rejected** - too much maintenance overhead.

### Option 3: Use Production Data with Env Flag

Point tests at `opas/public/data/` when available, fixtures when not. **Hybrid approach** - use this for comprehensive local testing, fixtures for CI.

## Test Structure

### Test Files Organization

```
opas/tests/
â”œâ”€â”€ e2e/
â”‚   â”œâ”€â”€ app.spec.ts              # Basic app loading
â”‚   â”œâ”€â”€ zones.spec.ts            # Zone rendering & data
â”‚   â”œâ”€â”€ heatmap.spec.ts          # Heatmap color buckets
â”‚   â”œâ”€â”€ selection.spec.ts        # Zone selection & interaction
â”‚   â”œâ”€â”€ journey-details.spec.ts  # Hover states & journey info
â”‚   â”œâ”€â”€ time-periods.spec.ts     # Morning/Evening/Midnight toggle
â”‚   â”œâ”€â”€ console-errors.spec.ts   # Console error monitoring
â”‚   â””â”€â”€ fixtures.spec.ts         # Fixture validation tests
â”œâ”€â”€ fixtures/
â”‚   â”œâ”€â”€ README.md                # How to regenerate fixtures
â”‚   â”œâ”€â”€ zones.json
â”‚   â”œâ”€â”€ manifest.json
â”‚   â”œâ”€â”€ background_map.json
â”‚   â””â”€â”€ routes/
â”‚       â”œâ”€â”€ HEL-101-M.msgpack
â”‚       â”œâ”€â”€ HEL-101-E.msgpack
â”‚       â””â”€â”€ ...
â””â”€â”€ helpers/
    â”œâ”€â”€ fixture-generator.ts     # Script to snapshot test data
    â”œâ”€â”€ test-utils.ts            # Shared test utilities
    â””â”€â”€ console-monitor.ts       # Console error tracking
```

## Test ID Additions Needed

### Components requiring data-testid attributes:

**App.vue:**
- âœ… `app-root` - exists
- âž• `transport-mode-public` - PUBLIC button
- âž• `transport-mode-bike` - BIKE button
- âž• `transport-mode-car` - CAR button
- âž• `time-period-morning` - MORNING button
- âž• `time-period-evening` - EVENING button
- âž• `time-period-midnight` - MIDNIGHT button
- âž• `loading-state` - loading spinner container
- âž• `error-state` - error message container
- âž• `retry-button` - retry button in error state

**BackgroundMap.vue:**
- âž• `background-map` - root container
- âž• `background-map-svg` - SVG element

**InteractiveMap.vue:**
- âž• `interactive-map` - root container
- âž• `interactive-map-svg` - SVG element
- âž• `zones-layer` - already exists as class, add testid
- âž• `route-paths` - route visualization layer

**HeatmapLegend.vue:**
- âž• `heatmap-legend` - legend container
- âž• `legend-title` - "Connectivity" or "Travel Time" title
- âž• `legend-bucket-{number}` - each time bucket item

**InfoPanel.vue:**
- âž• `info-panel` - root container
- âž• `info-panel-close` - close button (X)
- âž• `zone-name` - zone title
- âž• `zone-city` - city name
- âž• `zone-rank` - connectivity rank
- âž• `zones-within-15min` - count
- âž• `zones-within-30min` - count
- âž• `avg-travel-time` - average time

**JourneyPanel.vue:**
- âž• `journey-panel` - root container
- âž• `journey-hint` - hint state (ðŸ‘†)
- âž• `journey-error` - no route found (âŒ)
- âž• `journey-from` - origin zone name
- âž• `journey-to` - destination zone name
- âž• `journey-duration` - travel time

**ZonePolygon.vue:**
- âž• `zone-{zoneId}` - individual zone polygon
- âž• `zone-selected-{zoneId}` - selected zone border
- âž• `zone-hovered-{zoneId}` - hovered zone border

## Test Cases

### 1. App Loading & Basic Rendering

**File:** `app.spec.ts`

```typescript
test('loads without console errors', async ({ page }) => {
  const errors = []
  page.on('console', msg => {
    if (msg.type() === 'error') errors.push(msg.text())
  })

  await page.goto('/')
  await expect(page.getByTestId('app-root')).toBeVisible()
  expect(errors).toHaveLength(0)
})

test('shows loading state then map', async ({ page }) => {
  await page.goto('/')
  // May briefly show loading
  await expect(page.getByTestId('interactive-map')).toBeVisible({ timeout: 5000 })
})

test('shows error state on data load failure', async ({ page }) => {
  // Mock 404 for zones.json
  await page.route('**/data/zones.json', route => route.abort())
  await page.goto('/')
  await expect(page.getByTestId('error-state')).toBeVisible()
  await expect(page.getByTestId('retry-button')).toBeVisible()
})
```

### 2. Zone Rendering

**File:** `zones.spec.ts`

```typescript
test('renders all fixture zones', async ({ page }) => {
  await page.goto('/')
  await expect(page.getByTestId('interactive-map')).toBeVisible()

  // Check specific test zones are rendered
  const testZones = ['HEL-101', 'ESP-111', 'VAN-151']
  for (const zoneId of testZones) {
    await expect(page.getByTestId(`zone-${zoneId}`)).toBeVisible()
  }
})

test('routing points are visible', async ({ page }) => {
  await page.goto('/')
  const svg = page.getByTestId('interactive-map-svg')

  // Check that routing point circles exist
  const circles = svg.locator('circle[r="3"]')
  await expect(circles.first()).toBeVisible()
})
```

### 3. Console Error Monitoring

**File:** `console-errors.spec.ts`

**Strategy:** Every test file imports a global fixture that monitors console

```typescript
// Shared fixture in playwright.config.ts
test.beforeEach(async ({ page }) => {
  const errors = []
  page.on('console', msg => {
    if (msg.type() === 'error') {
      errors.push({ text: msg.text(), location: msg.location() })
    }
  })

  // Expose to test
  await page.exposeFunction('getConsoleErrors', () => errors)
})

test.afterEach(async ({ page }) => {
  const errors = await page.evaluate(() => window.getConsoleErrors())
  if (errors.length > 0) {
    console.error('Console errors detected:', errors)
    throw new Error(`Test generated ${errors.length} console error(s)`)
  }
})
```

### 4. Heatmap Colors

**File:** `heatmap.spec.ts`

```typescript
test('zones have different colors in reachability mode', async ({ page }) => {
  await page.goto('/')

  // Get fill colors of different zones
  const zone1Color = await page.getByTestId('zone-HEL-101')
    .evaluate(el => window.getComputedStyle(el).fill)
  const zone2Color = await page.getByTestId('zone-ESP-111')
    .evaluate(el => window.getComputedStyle(el).fill)

  // Should have different connectivity = different colors
  expect(zone1Color).not.toBe(zone2Color)
})

test('legend shows connectivity buckets initially', async ({ page }) => {
  await page.goto('/')

  await expect(page.getByTestId('legend-title')).toContainText('Connectivity')
  await expect(page.getByTestId('legend-bucket-1')).toBeVisible() // 15min
  await expect(page.getByTestId('legend-bucket-6')).toBeVisible() // 1h 30min
})
```

### 5. Zone Selection & Animation

**File:** `selection.spec.ts`

```typescript
test('clicking zone selects it and updates colors', async ({ page }) => {
  await page.goto('/')
  await expect(page.getByTestId('interactive-map')).toBeVisible()

  // Click a well-connected zone
  await page.getByTestId('zone-HEL-101').click()

  // InfoPanel should show zone details
  await expect(page.getByTestId('zone-name')).toContainText('Vilhonvuori')
  await expect(page.getByTestId('zone-rank')).toBeVisible()

  // Legend should change to Travel Time
  await expect(page.getByTestId('legend-title')).toContainText('Travel Time')

  // Wait for animation to complete (max delay ~300ms based on code)
  await page.waitForTimeout(500)

  // Zones should have different colors now (travel time based)
  const zoneColor = await page.getByTestId('zone-ESP-111')
    .evaluate(el => window.getComputedStyle(el).fill)
  expect(zoneColor).toBeTruthy()
})

test('ESC key deselects zone', async ({ page }) => {
  await page.goto('/')

  await page.getByTestId('zone-HEL-101').click()
  await expect(page.getByTestId('zone-name')).toBeVisible()

  await page.keyboard.press('Escape')

  // Should return to discovery mode
  await expect(page.getByTestId('info-panel')).toContainText('Discover Helsinki')
})

test('close button deselects zone', async ({ page }) => {
  await page.goto('/')

  await page.getByTestId('zone-HEL-101').click()
  await expect(page.getByTestId('info-panel-close')).toBeVisible()

  await page.getByTestId('info-panel-close').click()

  await expect(page.getByTestId('info-panel')).toContainText('Discover Helsinki')
})
```

### 6. Journey Details on Hover

**File:** `journey-details.spec.ts`

```typescript
test('hovering zone shows journey details when zone selected', async ({ page }) => {
  await page.goto('/')

  // Select origin zone
  await page.getByTestId('zone-HEL-101').click()

  // Should show hint initially
  await expect(page.getByTestId('journey-hint')).toBeVisible()
  await expect(page.getByTestId('journey-hint')).toContainText('Vilhonvuori')

  // Hover over destination zone
  await page.getByTestId('zone-HEL-201').hover()

  // Should show journey details
  await expect(page.getByTestId('journey-from')).toContainText('Vilhonvuori')
  await expect(page.getByTestId('journey-to')).toBeVisible()
  await expect(page.getByTestId('journey-duration')).toContainText('min')
})

test('shows no route error for unreachable zones', async ({ page }) => {
  await page.goto('/')

  // Select zone
  await page.getByTestId('zone-HEL-101').click()

  // Hover over zone with no route (fixture has one)
  await page.getByTestId('zone-ISOLATED-01').hover()

  await expect(page.getByTestId('journey-error')).toBeVisible()
  await expect(page.getByTestId('journey-error')).toContainText('No route found')
})
```

### 7. Time Period Toggle

**File:** `time-periods.spec.ts`

```typescript
test('switching time periods updates map data', async ({ page }) => {
  await page.goto('/')

  // Select a zone
  await page.getByTestId('zone-HEL-101').click()

  // Get initial travel time to another zone
  await page.getByTestId('zone-HEL-201').hover()
  const morningDuration = await page.getByTestId('journey-duration').textContent()

  // Switch to Evening
  await page.getByTestId('time-period-evening').click()

  // Wait for data to reload
  await page.waitForTimeout(300)

  // Duration might be different (or same, but data should reload)
  await page.getByTestId('zone-HEL-201').hover()
  const eveningDuration = await page.getByTestId('journey-duration').textContent()

  expect(eveningDuration).toBeTruthy()
  // Colors should update (hard to test precisely, but no errors should occur)
})

test('midnight period works', async ({ page }) => {
  await page.goto('/')

  await page.getByTestId('time-period-midnight').click()

  // Should still render zones
  await expect(page.getByTestId('zone-HEL-101')).toBeVisible()

  // Select zone and check connectivity still works
  await page.getByTestId('zone-HEL-101').click()
  await expect(page.getByTestId('zone-rank')).toBeVisible()
})
```

## Fixture Generation Script

**File:** `tests/helpers/fixture-generator.ts`

```typescript
import fs from 'fs/promises'
import path from 'path'

const FIXTURE_ZONES = [
  'HEL-101', // Central
  'HEL-201', // Different area
  'ESP-111', // Espoo
  'VAN-151', // Vantaa
  'ISOLATED-01', // No routes (create manually)
  // ... more zones
]

async function generateFixtures() {
  const sourceDir = path.join(__dirname, '../../public/data')
  const fixtureDir = path.join(__dirname, '../fixtures')

  // Read full zones.json
  const zonesData = JSON.parse(await fs.readFile(
    path.join(sourceDir, 'zones.json'), 'utf-8'
  ))

  // Filter to test zones only
  const testZones = zonesData.zones.filter(z =>
    FIXTURE_ZONES.includes(z.id)
  )

  const fixtureData = {
    ...zonesData,
    zones: testZones
  }

  // Write minimal zones.json
  await fs.writeFile(
    path.join(fixtureDir, 'zones.json'),
    JSON.stringify(fixtureData, null, 2)
  )

  // Copy route files for test zones
  const routesDir = path.join(fixtureDir, 'routes')
  await fs.mkdir(routesDir, { recursive: true })

  for (const zoneId of FIXTURE_ZONES) {
    for (const period of ['M', 'E', 'N']) {
      const filename = `${zoneId}-${period}.msgpack`
      const source = path.join(sourceDir, 'routes', filename)
      const dest = path.join(routesDir, filename)

      try {
        await fs.copyFile(source, dest)
      } catch (e) {
        console.warn(`Missing route file: ${filename}`)
      }
    }
  }

  // Copy manifest
  await fs.copyFile(
    path.join(sourceDir, 'manifest.json'),
    path.join(fixtureDir, 'manifest.json')
  )

  console.log('âœ… Fixtures generated successfully')
}

generateFixtures()
```

## Playwright Configuration Updates

```typescript
// playwright.config.ts
export default defineConfig({
  // ... existing config

  use: {
    baseURL: process.env.USE_FIXTURES
      ? 'http://localhost:5174' // Separate server for fixtures
      : 'http://localhost:5173', // Normal dev server
  },

  // Global console error tracking
  globalSetup: require.resolve('./tests/helpers/global-setup.ts'),
})
```

## Commands to Add

```json
// opas/package.json
{
  "scripts": {
    "test": "playwright test",
    "test:ui": "playwright test --ui",
    "test:headed": "playwright test --headed",
    "test:fixtures": "USE_FIXTURES=1 playwright test",
    "test:create-fixtures": "tsx tests/helpers/fixture-generator.ts",
    "test:validate-fixtures": "tsx tests/helpers/fixture-validator.ts",
    "test:dev-fixtures": "USE_FIXTURES=1 vite --port 5174 --config vite.config.fixtures.ts"
  }
}
```

## Summary & Questions

**Recommended Approach:**
1. Create minimal fixture set (10 zones) committed to git
2. Add comprehensive test IDs to all components
3. Implement console error monitoring for ALL tests
4. Write focused test files for each feature area
5. Use fixture mode for CI, optionally use full data for local comprehensive testing

**Open Questions:**

1. **Fixture zones:** Should we pick specific zones manually, or algorithmically select based on connectivity distribution?

2. **Fixture updates:** How often should we regenerate fixtures? On every Varikko format change? Weekly?

3. **Missing data:** Should we create a completely fake "ISOLATED-01" zone with zero routes, or find a real one in the dataset?

4. **Animation timing:** Tests wait 500ms for zone color animations. Is this reliable or should we add a data attribute that signals animation completion?

5. **Console errors:** Should ANY console error fail the test, or only unexpected ones? (Some libraries log warnings)

6. **Coverage goals:** What test coverage % are we targeting? 80% line coverage? Focus on critical paths only?
